---
title: Searching & Filtering
description: Learn how to implement schema-driven search and filtering in Nubase applications.
---

Nubase provides a schema-driven approach to searching and filtering data. Instead of manually configuring filter inputs, you define your filter schema once and Nubase automatically generates the filter UI, handles URL state, and passes parameters to your API.

## How It Works

The search flow in Nubase spans four layers:

1. **Schema** - Define the resource schema with field metadata
2. **Endpoint** - Create a GET endpoint with `requestParams` derived from the schema
3. **Backend** - Implement filtering logic using the typed parameters
4. **Frontend** - Configure the search view with `schemaFilter`

## Step 1: Define Your Schema

Start by defining your resource schema with appropriate metadata. Fields that should be searchable need labels and descriptions:

```typescript
// schema/src/resources/ticket.ts
import { nu } from "@nubase/core";

export const ticketSchema = nu
  .object({
    id: nu.number(),
    title: nu.string().withComputedMeta({
      label: "Title",
      description: "Enter the title of the ticket",
    }),
    description: nu.string().optional().withComputedMeta({
      label: "Description",
      description: "Enter the description of the ticket",
      renderer: "multiline",
    }),
    assigneeId: nu.number().optional().withComputedMeta({
      label: "Assignee",
      description: "Select a user to assign this ticket to",
      renderer: "lookup",
      lookupResource: "user",
    }),
  })
  .withId("id")
  .withTableLayouts({
    default: {
      fields: [
        { name: "id", columnWidthPx: 80, pinned: true },
        { name: "title", columnWidthPx: 300, pinned: true },
        { name: "description", columnWidthPx: 400 },
        { name: "assigneeId", columnWidthPx: 150 },
      ],
      metadata: {
        linkFields: ["title"],
      },
    },
  });
```

## Step 2: Create the Search Endpoint

Define a GET endpoint where `requestParams` specifies which fields can be filtered. Use `.omit()` to exclude fields like `id`, `.partial()` to make all filter fields optional, and `withSearchParams()` to enable global text search:

```typescript
// schema/src/endpoints/ticket/get-tickets.ts
import { nu, type RequestSchema, withSearchParams } from "@nubase/core";
import { ticketSchema } from "../../resources/ticket";

export const getTicketsSchema = {
  method: "GET" as const,
  path: "/tickets",
  requestParams: withSearchParams(ticketSchema.omit("id").partial()),
  responseBody: nu.array(ticketSchema),
} satisfies RequestSchema;
```

The `requestParams` schema defines what filters are available:
- `withSearchParams()` - Adds a global `q` parameter for text search across multiple fields
- `ticketSchema.omit("id")` - Exclude the ID field from filters
- `.partial()` - Make all fields optional (users don't need to fill every filter)

## Step 3: Implement Backend Filtering

In your backend route handler, use the typed `params` to build database queries:

```typescript
// backend/src/api/routes/ticket.ts
import { createHttpHandler } from "@nubase/backend";
import { and, eq, ilike, inArray, or } from "drizzle-orm";
import type { SQL } from "drizzle-orm";
import { apiEndpoints } from "schema";
import { getDb } from "../../db/helpers/drizzle";
import { tickets } from "../../db/schema";

export const ticketHandlers = {
  getTickets: createHttpHandler({
    endpoint: apiEndpoints.getTickets,
    handler: async ({ params }) => {
      const db = getDb();

      // Build filter conditions dynamically
      const conditions: SQL[] = [];

      // Global text search - OR across multiple text fields
      if (params.q) {
        const searchTerm = `%${params.q}%`;
        const searchCondition = or(
          ilike(tickets.title, searchTerm),
          ilike(tickets.description, searchTerm),
        );
        if (searchCondition) {
          conditions.push(searchCondition);
        }
      }

      // Field-specific filters (AND with global search)
      if (params.title) {
        conditions.push(ilike(tickets.title, `%${params.title}%`));
      }

      if (params.description) {
        conditions.push(ilike(tickets.description, `%${params.description}%`));
      }

      // Lookup field - supports both single value and array (multi-select)
      if (params.assigneeId !== undefined) {
        if (Array.isArray(params.assigneeId)) {
          if (params.assigneeId.length > 0) {
            conditions.push(inArray(tickets.assigneeId, params.assigneeId));
          }
        } else {
          conditions.push(eq(tickets.assigneeId, params.assigneeId));
        }
      }

      // Execute query with conditions
      const results = conditions.length > 0
        ? await db.select().from(tickets).where(and(...conditions))
        : await db.select().from(tickets);

      return results.map((ticket) => ({
        id: ticket.id,
        title: ticket.title,
        description: ticket.description ?? undefined,
        assigneeId: ticket.assigneeId ?? undefined,
      }));
    },
  }),
};
```

### Filtering Patterns

| Field Type | Drizzle Function | Description |
|------------|------------------|-------------|
| Global search | `or(ilike(field1, q), ilike(field2, q))` | Search across multiple fields |
| Text search | `ilike(field, '%value%')` | Case-insensitive partial match |
| Exact match | `eq(field, value)` | Exact value comparison |
| Multi-select | `inArray(field, values)` | Match any value in array |
| Range | `between(field, min, max)` | Value within range |

## Global Text Search

The global text search feature allows users to search across multiple fields at once using a single search input. This is enabled by the `withSearchParams()` helper from `@nubase/core`.

### How It Works

1. **Schema**: Use `withSearchParams()` to add a `q` parameter to your endpoint
2. **Backend**: Check for `params.q` and search across relevant text fields using `or()`
3. **Frontend**: The search input is automatically rendered when the schema has a `q` field

The search input appears at the top of the filter bar and searches across all text fields you define in your backend handler. Field-specific filters are combined with global search using AND logic.

### Example: Global Search + Field Filters

```typescript
// When a user types "bug" in search and selects an assignee:
// URL: /r/ticket/search?q=bug&assigneeId=5
//
// Backend query conditions:
// 1. (title ILIKE '%bug%' OR description ILIKE '%bug%')  <- from q
// 2. AND assigneeId = 5                                   <- from filter
```

## Step 4: Configure the Frontend Search View

In your resource definition, use `schemaFilter` to enable the filter bar:

```typescript
// frontend/src/resources/ticket.ts
import { createResource } from "@nubase/frontend";
import { apiEndpoints } from "schema";

export const ticketResource = createResource("ticket")
  .withApiEndpoints(apiEndpoints)
  .withViews({
    search: {
      type: "resource-search",
      id: "search-tickets",
      title: "Search Tickets",
      schemaGet: (api) => api.getTickets.responseBody,
      schemaFilter: (api) => api.getTickets.requestParams,
      breadcrumbs: () => [{ label: "Tickets", to: "/r/ticket/search" }],
      onLoad: async ({ context }) => {
        return context.http.getTickets({
          params: context.params || {},
        });
      },
    },
  });
```

Key properties:

- **`schemaGet`** - Schema for the data grid columns (derived from response)
- **`schemaFilter`** - Schema for the filter bar (derived from request params)
- **`onLoad`** - Fetches data, passing `context.params` which contains current filter values

## Lookup Fields in Search

Lookup fields (like `assigneeId` pointing to a user) automatically render as searchable dropdowns in the filter bar. To enable this:

### 1. Define the Lookup Endpoint

```typescript
// schema/src/endpoints/user/lookup-users.ts
import { createLookupEndpoint, nu } from "@nubase/core";

export const lookupUsersSchema = createLookupEndpoint("users", nu.number());
```

### 2. Configure the Lookup Resource

```typescript
// frontend/src/resources/user.ts
import { createResource } from "@nubase/frontend";
import { apiEndpoints } from "schema";

export const userResource = createResource("user")
  .withApiEndpoints(apiEndpoints)
  .withLookup({
    onSearch: ({ query, context }) =>
      context.http.lookupUsers({ params: { q: query } }),
  })
  .withViews({
    // ... views
  });
```

### 3. Implement the Backend Lookup

```typescript
// backend/src/api/routes/user.ts
export const userHandlers = {
  lookupUsers: createHttpHandler({
    endpoint: apiEndpoints.lookupUsers,
    handler: async ({ params }) => {
      const db = getDb();

      const results = params.q
        ? await db
            .select()
            .from(users)
            .where(ilike(users.displayName, `%${params.q}%`))
            .limit(10)
        : await db.select().from(users).limit(10);

      return results.map((user) => ({
        id: user.id,
        label: user.displayName,
      }));
    },
  }),
};
```

The lookup field in the filter bar will:
- Show a searchable dropdown
- Call the lookup endpoint as users type
- Support multi-select for filtering by multiple assignees

## URL State Management

Filter values are automatically synced to the URL as query parameters:

```
/r/ticket/search?title=bug&assigneeId=5
```

This means:
- Users can bookmark filtered views
- Browser back/forward navigation works with filters
- Filters persist across page refreshes

## Complete Example

Here's a complete example showing all the pieces together:

### Schema Package

```typescript
// schema/src/resources/ticket.ts
export const ticketSchema = nu
  .object({
    id: nu.number(),
    title: nu.string().withComputedMeta({ label: "Title" }),
    status: nu.string().withComputedMeta({ label: "Status" }),
    assigneeId: nu.number().optional().withComputedMeta({
      label: "Assignee",
      renderer: "lookup",
      lookupResource: "user",
    }),
  })
  .withId("id");

// schema/src/endpoints/ticket/get-tickets.ts
import { withSearchParams } from "@nubase/core";

export const getTicketsSchema = {
  method: "GET" as const,
  path: "/tickets",
  requestParams: withSearchParams(ticketSchema.omit("id").partial()),
  responseBody: nu.array(ticketSchema),
} satisfies RequestSchema;
```

### Backend

```typescript
// backend/src/api/routes/ticket.ts
import { and, eq, ilike, inArray, or } from "drizzle-orm";

getTickets: createHttpHandler({
  endpoint: apiEndpoints.getTickets,
  handler: async ({ params }) => {
    const conditions: SQL[] = [];

    // Global text search
    if (params.q) {
      const searchTerm = `%${params.q}%`;
      const searchCondition = or(
        ilike(tickets.title, searchTerm),
        ilike(tickets.status, searchTerm),
      );
      if (searchCondition) {
        conditions.push(searchCondition);
      }
    }

    // Field-specific filters
    if (params.title) {
      conditions.push(ilike(tickets.title, `%${params.title}%`));
    }
    if (params.status) {
      conditions.push(eq(tickets.status, params.status));
    }
    if (params.assigneeId) {
      conditions.push(
        Array.isArray(params.assigneeId)
          ? inArray(tickets.assigneeId, params.assigneeId)
          : eq(tickets.assigneeId, params.assigneeId)
      );
    }

    return db.select().from(tickets)
      .where(conditions.length ? and(...conditions) : undefined);
  },
}),
```

### Frontend

```typescript
// frontend/src/resources/ticket.ts
export const ticketResource = createResource("ticket")
  .withApiEndpoints(apiEndpoints)
  .withViews({
    search: {
      type: "resource-search",
      id: "search-tickets",
      title: "Tickets",
      schemaGet: (api) => api.getTickets.responseBody,
      schemaFilter: (api) => api.getTickets.requestParams,
      onLoad: async ({ context }) => {
        return context.http.getTickets({
          params: context.params || {},
        });
      },
    },
  });
```

## Best Practices

1. **Use `withSearchParams()` for global search** - Enable the search input by wrapping your requestParams with `withSearchParams()`

2. **Use `.partial()` for filters** - All filter fields should be optional since users rarely fill every filter

3. **Use `ilike` for text search** - Case-insensitive partial matching provides the best user experience

4. **Use `or()` for global search** - Search across multiple text fields using OR logic so users find matches in any field

5. **Support arrays for lookups** - Allow multi-select by checking `Array.isArray()` and using `inArray()`

6. **Limit lookup results** - Always use `.limit()` on lookup queries to prevent loading too much data

7. **Keep filters focused** - Only expose filters that users actually need; too many filters can overwhelm

8. **Match requestParams to handler** - Every field in `requestParams` should have corresponding filter logic in the backend handler
